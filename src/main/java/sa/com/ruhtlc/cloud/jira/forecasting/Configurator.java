package sa.com.ruhtlc.cloud.jira.forecasting;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.ofbiz.core.entity.GenericEntityException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.atlassian.activeobjects.external.ActiveObjects;
import com.atlassian.jira.bc.projectroles.ProjectRoleService;
import com.atlassian.jira.config.managedconfiguration.ConfigurationItemAccessLevel;
import com.atlassian.jira.config.managedconfiguration.ManagedConfigurationItem;
import com.atlassian.jira.config.managedconfiguration.ManagedConfigurationItemBuilder;
import com.atlassian.jira.config.properties.APKeys;
import com.atlassian.jira.issue.IssueFieldConstants;
import com.atlassian.jira.issue.context.GlobalIssueContext;
import com.atlassian.jira.issue.context.JiraContextNode;
import com.atlassian.jira.issue.customfields.CustomFieldUtils;
import com.atlassian.jira.issue.customfields.option.Option;
import com.atlassian.jira.issue.customfields.option.Options;
import com.atlassian.jira.issue.customfields.persistence.CustomFieldValuePersister;
import com.atlassian.jira.issue.fields.CustomField;
import com.atlassian.jira.issue.fields.FieldException;
import com.atlassian.jira.issue.fields.NavigableField;
import com.atlassian.jira.issue.fields.config.FieldConfig;
import com.atlassian.jira.issue.fields.config.FieldConfigScheme;
import com.atlassian.jira.issue.fields.layout.field.EditableDefaultFieldLayout;
import com.atlassian.jira.issue.fields.layout.field.EditableFieldLayout;
import com.atlassian.jira.issue.fields.layout.field.EditableFieldLayoutImpl;
import com.atlassian.jira.issue.fields.layout.field.FieldLayout;
import com.atlassian.jira.issue.fields.layout.field.FieldLayoutScheme;
import com.atlassian.jira.issue.fields.screen.FieldScreen;
import com.atlassian.jira.issue.fields.screen.FieldScreenImpl;
import com.atlassian.jira.issue.fields.screen.FieldScreenScheme;
import com.atlassian.jira.issue.fields.screen.FieldScreenSchemeImpl;
import com.atlassian.jira.issue.fields.screen.FieldScreenSchemeItemImpl;
import com.atlassian.jira.issue.fields.screen.FieldScreenSchemeManager;
import com.atlassian.jira.issue.fields.screen.FieldScreenTab;
import com.atlassian.jira.issue.fields.screen.issuetype.IssueTypeScreenScheme;
import com.atlassian.jira.issue.fields.screen.issuetype.IssueTypeScreenSchemeEntity;
import com.atlassian.jira.issue.fields.screen.issuetype.IssueTypeScreenSchemeEntityImpl;
import com.atlassian.jira.issue.fields.screen.issuetype.IssueTypeScreenSchemeImpl;
import com.atlassian.jira.issue.issuetype.IssueType;
import com.atlassian.jira.issue.operation.ScreenableIssueOperation;
import com.atlassian.jira.project.Project;
import com.atlassian.jira.security.roles.ProjectRole;
import com.atlassian.jira.security.roles.ProjectRoleImpl;
import com.atlassian.jira.util.SimpleErrorCollection;
import com.atlassian.plugin.spring.scanner.annotation.component.Scanned;
import com.atlassian.plugin.spring.scanner.annotation.imports.ComponentImport;

import sa.com.ruhtlc.cloud.jira.utils.Debugger;
import sa.com.ruhtlc.cloud.jira.utils.JC;

public class Configurator
{
	public static final String VERSION = "1.0.0";
	public static final String MESSAGE_FIELD_LAYOUT_CONFIGURATION_SCHEME = "[Autogenerated - DO NOT EDIT OR DELETE] Forecast plugin field layout configuration scheme for project ";
	public static final String MESSAGE_FIELD_CONFIGURATION = "[Autogenerated - DO NOT EDIT OR DELETE] Forecast plugin field configuration for project ";
	public static final String MESSAGE_FIELD_CONFIGURATION_SCHEME = "[Autogenerated - DO NOT EDIT OR DELETE] Forecast plugin field configuration scheme for project ";
	private static final Logger log = LoggerFactory.getLogger(Configurator.class);
	private static final Configurator singleton = new Configurator();

	public static Configurator getInstance()
	{
		return singleton;
	}

	private Properties properties;
	private IssueType forecastIssueType, forecastSubtaskIssueType;
	private CustomField forecastStatusCF, forecastCategoryCF;
	private CustomField forecastInitialPaymentAmountCF, forecastMonthlyPaymentsAmountCF, forecastMonthlyPaymentsDurationCF;
	private CustomField forecastTotalValueCF;
	private CustomField forecastClosingDateCF, forecastBookingDateCF, forecastDeliveryDateCF, forecastRecognitionDateCF;
	private CustomField forecastClosingDateReviewedCF, forecastBookingDateReviewedCF, forecastDeliveryDateReviewedCF, forecastRecognitionDateReviewedCF;
	private ProjectRole forecastReviewersRole;

	private Configurator() throws RuntimeException
	{
		InputStream inputStream = null;
		try
		{
			properties = new Properties();
			inputStream =
			    this.getClass().getClassLoader().getResourceAsStream("/configuration.properties");
			properties.load(inputStream);
			
			String enabledConfiguration = properties.getProperty("scscjf.configuration.enable", "true").toLowerCase();
			if ( !enabledConfiguration.equals("true") )
				throw new IllegalStateException("Configuration file indicates disable plugin (set 'scscjf.configuration.enable' to true otherwise).");
			log.info("Configuration properties file loaded");
		}
		catch (Exception e)
		{
			log.error("Unable to load configuration.properties", e);
			throw new RuntimeException(e);
		}
		finally
		{
			if (inputStream != null)
				try { inputStream.close(); } catch (Exception e) {}
		}
	}
	
	public void enable() throws Exception
	{
		// loadFieldDisplayManagerJavascript();

		/*
		log.debug("Waiting for ActiveObjects to initialize.");
		JC.activeObjects.moduleMetaData().awaitInitialization();
		log.debug("Finished waiting for ActiveObjects to initialize.");
		*/
		// Debugger.logAllNavigableFields(log);

		// ####################################################################
		// ##### ADD THE FORECAST ISSUE TYPE AND SUBTASK ISSUE TYPE IF NON-EXISTING
		// https://jira.atlassian.com/browse/JRA-44229
		forecastIssueType = getOrCreateIssueType(Constants.ISSUE_TYPE_FORECAST_NAME, Constants.ISSUE_TYPE_FORECAST_DESCRIPTION, false);
		forecastSubtaskIssueType = getOrCreateIssueType(Constants.ISSUE_TYPE_FORECAST_SUBTASK_NAME, Constants.ISSUE_TYPE_FORECAST_SUBTASK_DESCRIPTION, true);

		String[] forecastIssueTypeIds = { forecastIssueType.getId(), forecastSubtaskIssueType.getId() };

		// ####################################################################
		// ##### ADD FORECAST CUSTOM FIELDS IF NON-EXISTING
		// Prepare a global context (the custom fields will be available to all projects)
		List<JiraContextNode> globalContextList = Arrays.asList(GlobalIssueContext.getInstance());
		// And also available to all issue types. Two variables for two different method calls but the same purpose.
		List<IssueType> unrestrictedIssueTypeContextList = new ArrayList<IssueType>();
		unrestrictedIssueTypeContextList.add(null); // JIRA expects a single null element in the list to mean global issue types (all of them)
		String[] unrestrictedIssueTypeIdArray = new String[] { null };

		// If the custom field exists for ANY context, then do not recreate it. We accept that the user may have customized the context.
		
		forecastStatusCF = getOrCreateSelectCustomField( 
			Constants.CUSTOM_FIELD_FORECAST_STATUS_NAME, Constants.CUSTOM_FIELD_FORECAST_STATUS_DESCRIPTION, 
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.ADMIN);
		
		forecastCategoryCF = getOrCreateSelectCustomField( 
			Constants.CUSTOM_FIELD_FORECAST_CATEGORY_NAME, Constants.CUSTOM_FIELD_FORECAST_CATEGORY_DESCRIPTION, 
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.ADMIN);

		forecastClosingDateCF = getOrCreateDatePickerCustomField(
			Constants.CUSTOM_FIELD_FORECAST_CLOSING_DATE_NAME, 
			Constants.CUSTOM_FIELD_FORECAST_CLOSING_DATE_DESCRIPTION,
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		forecastBookingDateCF = getOrCreateDatePickerCustomField(
			Constants.CUSTOM_FIELD_FORECAST_BOOKING_DATE_NAME, 
			Constants.CUSTOM_FIELD_FORECAST_BOOKING_DATE_DESCRIPTION,
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		forecastDeliveryDateCF = getOrCreateDatePickerCustomField(
			Constants.CUSTOM_FIELD_FORECAST_DELIVERY_DATE_NAME, 
			Constants.CUSTOM_FIELD_FORECAST_DELIVERY_DATE_DESCRIPTION,
			//	+ "\n<script type=\"text/javascript\">\n" + fieldDisplayManagerJavascript + "\n</script>",
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		forecastRecognitionDateCF = getOrCreateDatePickerCustomField(
			Constants.CUSTOM_FIELD_FORECAST_RECOGNITION_DATE_NAME, 
			Constants.CUSTOM_FIELD_FORECAST_RECOGNITION_DATE_DESCRIPTION,
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);

		forecastClosingDateReviewedCF = getOrCreateCheckboxCustomField(
			Constants.CUSTOM_FIELD_FORECAST_CLOSING_DATE_REVIEWED_NAME, 
			Constants.CUSTOM_FIELD_FORECAST_CLOSING_DATE_REVIEWED_DESCRIPTION,
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		forecastBookingDateReviewedCF = getOrCreateCheckboxCustomField(
			Constants.CUSTOM_FIELD_FORECAST_BOOKING_DATE_REVIEWED_NAME, 
			Constants.CUSTOM_FIELD_FORECAST_BOOKING_DATE_REVIEWED_DESCRIPTION,
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		forecastDeliveryDateReviewedCF = getOrCreateCheckboxCustomField(
			Constants.CUSTOM_FIELD_FORECAST_DELIVERY_DATE_REVIEWED_NAME, 
			Constants.CUSTOM_FIELD_FORECAST_DELIVERY_DATE_REVIEWED_DESCRIPTION,
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		forecastRecognitionDateReviewedCF = getOrCreateCheckboxCustomField(
			Constants.CUSTOM_FIELD_FORECAST_RECOGNITION_DATE_REVIEWED_NAME, 
			Constants.CUSTOM_FIELD_FORECAST_RECOGNITION_DATE_REVIEWED_DESCRIPTION,
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);

		forecastInitialPaymentAmountCF = getOrCreateNumberCustomField( 
			Constants.CUSTOM_FIELD_FORECAST_INITIAL_PAYMENT_AMOUNT_NAME, Constants.CUSTOM_FIELD_FORECAST_INITIAL_PAYMENT_AMOUNT_DESCRIPTION, 
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		forecastMonthlyPaymentsAmountCF = getOrCreateNumberCustomField( 
			Constants.CUSTOM_FIELD_FORECAST_MONTHLY_PAYMENTS_AMOUNT_NAME, Constants.CUSTOM_FIELD_FORECAST_MONTHLY_PAYMENTS_AMOUNT_DESCRIPTION, 
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		forecastMonthlyPaymentsDurationCF = getOrCreateNumberCustomField( 
			Constants.CUSTOM_FIELD_FORECAST_MONTHLY_PAYMENTS_DURATION_NAME, Constants.CUSTOM_FIELD_FORECAST_MONTHLY_PAYMENTS_DURATION_DESCRIPTION, 
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		forecastTotalValueCF = getOrCreateNumberCustomField( 
			Constants.CUSTOM_FIELD_FORECAST_TOTAL_VALUE_NAME, Constants.CUSTOM_FIELD_FORECAST_TOTAL_VALUE_DESCRIPTION, 
			globalContextList, unrestrictedIssueTypeContextList, false, ConfigurationItemAccessLevel.LOCKED);
		
		// ####################################################################
		// ##### ADD FORECAST CUSTOM FIELD OPTIONS IF NOT SET
		setOptionsForProjectNeutralFieldConfigurationSchemes(unrestrictedIssueTypeIdArray, forecastStatusCF, Constants.CUSTOM_FIELD_FORECAST_STATUS_DEFAULT_OPTION_NUMBER,
			Constants.CUSTOM_FIELD_FORECAST_STATUS_OPTIONS);
		setOptionsForProjectNeutralFieldConfigurationSchemes(unrestrictedIssueTypeIdArray, forecastCategoryCF, Constants.CUSTOM_FIELD_FORECAST_CATEGORY_DEFAULT_OPTION_NUMBER,
			Constants.CUSTOM_FIELD_FORECAST_CATEGORY_OPTIONS);
		setOptionsForProjectNeutralFieldConfigurationSchemes(unrestrictedIssueTypeIdArray, forecastClosingDateReviewedCF, -1,
			Constants.VALUES_YES);
		setOptionsForProjectNeutralFieldConfigurationSchemes(unrestrictedIssueTypeIdArray, forecastBookingDateReviewedCF, -1,
			Constants.VALUES_YES);
		setOptionsForProjectNeutralFieldConfigurationSchemes(unrestrictedIssueTypeIdArray, forecastDeliveryDateReviewedCF, -1,
			Constants.VALUES_YES);
		setOptionsForProjectNeutralFieldConfigurationSchemes(unrestrictedIssueTypeIdArray, forecastRecognitionDateReviewedCF, -1,
			Constants.VALUES_YES);

		// ####################################################################
		// ##### ADD FORECAST SCREEN IF NON-EXISTING
		ArrayList<String> fieldIds = new ArrayList<String>();
		// to check built-in field names taken from target/jira/webapp/WEB-INF/classes/startupdatabase.xml
		fieldIds.add(IssueFieldConstants.SUMMARY);
		fieldIds.add(IssueFieldConstants.ASSIGNEE);
		fieldIds.add(forecastCategoryCF.getId());
		fieldIds.add(forecastStatusCF.getId());
		fieldIds.add(forecastClosingDateCF.getId());
		fieldIds.add(forecastClosingDateReviewedCF.getId());
		fieldIds.add(forecastBookingDateCF.getId());
		fieldIds.add(forecastBookingDateReviewedCF.getId());
		fieldIds.add(forecastDeliveryDateCF.getId());
		fieldIds.add(forecastDeliveryDateReviewedCF.getId());
		fieldIds.add(forecastRecognitionDateCF.getId());
		fieldIds.add(forecastRecognitionDateReviewedCF.getId());
		fieldIds.add(forecastInitialPaymentAmountCF.getId());
		fieldIds.add(forecastMonthlyPaymentsAmountCF.getId());
		fieldIds.add(forecastMonthlyPaymentsDurationCF.getId());
		fieldIds.add(forecastTotalValueCF.getId());
		fieldIds.add(IssueFieldConstants.DESCRIPTION);
		fieldIds.add(IssueFieldConstants.ISSUE_LINKS);

		FieldScreen forecastScreen = getOrCreateSingleTabFieldScreen(
			Constants.SCREEN_FORECAST_SCREEN_NAME, Constants.SCREEN_FORECAST_SCREEN_DESCRIPTION, Constants.SCREEN_FORECAST_SCREEN_TAB1_NAME,
			fieldIds);

		// ####################################################################
		// ##### ADD SCREEN SCHEME MAPPING ALL OPERATIONS TO FORECAST SCREEN IF NON-EXISTING
		FieldScreenScheme forecastOperationsScreenScheme = getOrCreateFieldScreenScheme(
			Constants.SCREEN_FORECAST_SCREEN_SCHEME_NAME, Constants.SCREEN_FORECAST_SCREEN_SCHEME_DESCRIPTION, forecastScreen, null);

		// ####################################################################
		// ##### MAP FORECAST SCREEN SCHEME TO FORECAST ISSUE TYPE (FORECAST ISSUE TYPE SCREEN SCHEME) IF NON-EXISTING
		IssueTypeScreenScheme forecastIssueTypeScreenScheme = 
			getOrCreateIssueTypeScreenScheme(
				Constants.SCREEN_FORECAST_ISSUE_TYPE_SCREEN_SCHEME_NAME, Constants.SCREEN_FORECAST_ISSUE_TYPE_SCREEN_SCHEME_DESCRIPTION,
				forecastOperationsScreenScheme, forecastIssueTypeIds);
		
		// ####################################################################
		// ##### ADD PROJECT ROLE FOR AUTHORIZED REVIEWERS OF FORECASTS
		// ProjectRole projectRole = JC.projectRoleService.createProjectRole(new ProjectRoleImpl("TestRole"+System.currentTimeMillis(), "Test Role Description"), errorCollection);
		forecastReviewersRole = getOrCreateProjectRole(Constants.PROJECT_ROLE_FORECAST_REVIEWERS_NAME, Constants.PROJECT_ROLE_FORECAST_REVIEWERS_DESCRIPTION);
		
		// ####################################################################
		// ####################################################################
		// ####################################################################

		/*
		 * UI NAME				: CLASS NAME
		 * Field Configuration	: FieldLayout
		 */
/*		List<FieldLayoutScheme> fieldLayoutSchemes = JC.fieldLayoutManager.getFieldLayoutSchemes();
		StringBuilder buff = new StringBuilder();
		buff.append("\nStart of debugging output");
		for (FieldLayoutScheme fieldLayoutScheme : fieldLayoutSchemes)
		{
			buff.append("\n\tField Layout Scheme (UI calls this 'Field Configuration Schemes'): " + fieldLayoutScheme);
		}
		buff.append("\n\t").append("Default Field Layout Name (UI calls this 'Default Field Configuration'): ").append(JC.fieldLayoutManager.getFieldLayout().getName());
		
		//FieldLayout fieldLayout = JC.fieldLayoutManager.getFieldLayout(JC.projectManager.getProjectByCurrentKey("TEST"), forecastIssueType.getId());
		//buff.append("\n\t").append("Field Layout for Project Test, Issue Type Forecast: ").append(fieldLayout.getName()).append(" -> Default: ").append(fieldLayout.isDefault());
		
		//createProjectSpecificFieldLayout(JC.projectManager.getProjectByCurrentKey("TEST").getId());

		
		buff.append("\nEnd of debugging output");
		log.debug(buff.toString());
*/				
		/*
		 * Create a project-specific field configuration if not existing
		 * - configure it per the latest forecasting fields options settings
		 * If the project is associated with the default field configuration scheme
		 * - create a new field configuration scheme that is non-default
		 * If the project is associated with a non-default field configuration scheme
		 * - add an issue type to field configuration mapping to that scheme (for the two forecast issue types)
		 */
	}
	
	public EditableFieldLayout createProjectSpecificFieldLayout(Long projectId)
	{
		// Retrieve default field configuration
		EditableDefaultFieldLayout defaultFieldLayout = JC.fieldLayoutManager.getEditableDefaultFieldLayout();
		
		// Make a new field configuration based on the default
		EditableFieldLayout projectSpecificFieldLayout = new EditableFieldLayoutImpl(null, defaultFieldLayout.getFieldLayoutItems());
		projectSpecificFieldLayout.setName(MESSAGE_FIELD_CONFIGURATION + projectId);
		projectSpecificFieldLayout.setDescription(MESSAGE_FIELD_CONFIGURATION + projectId + " " + new Date().toString());
		
		projectSpecificFieldLayout = JC.fieldLayoutManager.storeAndReturnEditableFieldLayout(projectSpecificFieldLayout);
		
		return projectSpecificFieldLayout;
	}
		
	public void disable() throws Exception
	{
		
	}
	
	private IssueType getOrCreateIssueType(String issueTypeName, String issueTypeDescription, boolean isSubtask)
	{
		IssueType issueType = getIssueTypeByName(issueTypeName);
		if (issueType == null)
		{
			if (!isSubtask)
			{
				// https://jira.atlassian.com/browse/JRA-39437
				Long avatarId = Long.valueOf(JC.applicationProperties.getString(APKeys.JIRA_DEFAULT_ISSUETYPE_AVATAR_ID));
	
				issueType = JC.issueTypeManager.createIssueType(issueTypeName, issueTypeDescription, avatarId);
			}
			else
			{
				Long avatarId = Long.valueOf(JC.applicationProperties.getString(APKeys.JIRA_DEFAULT_ISSUETYPE_SUBTASK_AVATAR_ID));
				
				issueType = JC.issueTypeManager.createSubTaskIssueType(issueTypeName, issueTypeDescription, avatarId);
			}
			if (log.isDebugEnabled()) log.debug("Created new issue type for " + issueTypeName);
		}
		else
			if (log.isDebugEnabled()) log.debug("Found pre-existing issue type for " + issueTypeName);

		return issueType;
	}

	private CustomField getOrCreateNumberCustomField(String cfName, String cfDescription, 
		List<JiraContextNode> contextNodes, List<IssueType> issueTypeContexts, boolean isRequired, ConfigurationItemAccessLevel accessLevel) throws GenericEntityException
	{
		return getOrCreateCustomField(cfName, cfDescription, contextNodes, issueTypeContexts, 
			"com.atlassian.jira.plugin.system.customfieldtypes:float",
			"com.atlassian.jira.plugin.system.customfieldtypes:exactnumber", isRequired, accessLevel);
	}

	private CustomField getOrCreateTextAreaCustomField(String cfName, String cfDescription, 
		List<JiraContextNode> contextNodes, List<IssueType> issueTypeContexts, boolean isRequired, ConfigurationItemAccessLevel accessLevel) throws GenericEntityException
	{
		return getOrCreateCustomField(cfName, cfDescription, contextNodes, issueTypeContexts, 
			"com.atlassian.jira.plugin.system.customfieldtypes:textarea",
			"com.atlassian.jira.plugin.system.customfieldtypes:textsearcher", isRequired, accessLevel);
	}

	private CustomField getOrCreateDatePickerCustomField(String cfName, String cfDescription, 
		List<JiraContextNode> contextNodes, List<IssueType> issueTypeContexts, boolean isRequired, ConfigurationItemAccessLevel accessLevel) throws GenericEntityException
	{
		return getOrCreateCustomField(cfName, cfDescription, contextNodes, issueTypeContexts, 
			"com.atlassian.jira.plugin.system.customfieldtypes:datepicker",
			"com.atlassian.jira.plugin.system.customfieldtypes:daterange", isRequired, accessLevel);
	}

	private CustomField getOrCreateSelectCustomField(String cfName, String cfDescription, 
		List<JiraContextNode> contextNodes, List<IssueType> issueTypeContexts, boolean isRequired, ConfigurationItemAccessLevel accessLevel) throws GenericEntityException
	{
		return getOrCreateCustomField(cfName, cfDescription, contextNodes, issueTypeContexts, 
			"com.atlassian.jira.plugin.system.customfieldtypes:select",
			"com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher", isRequired, accessLevel);
	}

	private CustomField getOrCreateCheckboxCustomField(String cfName, String cfDescription, 
		List<JiraContextNode> contextNodes, List<IssueType> issueTypeContexts, boolean isRequired, ConfigurationItemAccessLevel accessLevel) throws GenericEntityException
	{
		return getOrCreateCustomField(cfName, cfDescription, contextNodes, issueTypeContexts,
			"com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes",
			"com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher", isRequired, accessLevel);
	}

	/**
	 * Note: If the custom field exists for ANY context, then do not recreate it. We accept that the user may have customized the context.
	 * <br/>
	 * Be <b>VERY CAREFUL</b> if making a custom field required: make sure to properly restrict its issue types to a limited set or
	 * else all issue types will require the custom field (almost certainly the wrong outcome).
	 * @param cfName custom field name
	 * @param cfDescription custom field description
	 * @param contextNodes context nodes
	 * @param issueTypeContexts issue type restrictions
	 * @param cfType type of custom field (string id, eg com.atlassian.jira.plugin.system.customfieldtypes:select)
	 * @param cfSearcher type of custom field searcher (string id, eg com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher)
	 * @param isRequired whether the field should be required in the DEFAULT field configuration
	 * @return newly created custom field
	 * @throws GenericEntityException
	 */
	private CustomField getOrCreateCustomField(String cfName, String cfDescription, 
		List<JiraContextNode> contextNodes, List<IssueType> issueTypeContexts,
		String cfType, String cfSearcher, boolean isRequired, ConfigurationItemAccessLevel accessLevel) 
		throws GenericEntityException
	{
		CustomField customField = JC.customFieldManager.getCustomFieldObjectByName(cfName);
		if (customField == null)
		{
			customField = JC.customFieldManager.createCustomField(
				cfName, 
				cfDescription, 
				JC.customFieldManager.getCustomFieldType(cfType), 
				JC.customFieldManager.getCustomFieldSearcher(cfSearcher), 
				contextNodes, 
				issueTypeContexts);

			if (isRequired)
			{
				// FYI: the "Field Layout" in Java is actually the "Field Configuration" in JIRA's UI
				// (not the "Field Configuration Scheme" with its own "Field Configuration"s!!!)
				EditableDefaultFieldLayout defaultFieldLayout = JC.fieldLayoutManager.getEditableDefaultFieldLayout();
				defaultFieldLayout.makeRequired( defaultFieldLayout.getFieldLayoutItem(customField.getId()) );
				JC.fieldLayoutManager.storeEditableDefaultFieldLayout( defaultFieldLayout );
			}
		
			// https://answers.atlassian.com/questions/24643272/how-do-i-make-customfield-locked-like-jira-agile-sprint-field.
			if (accessLevel != null)
			{
				ManagedConfigurationItem managedField = JC.managedConfigurationItemService.getManagedCustomField(customField);
				if (managedField != null)
				{
					ManagedConfigurationItemBuilder builder = ManagedConfigurationItemBuilder.builder(managedField);
					builder.setManaged(true);
					builder.setConfigurationItemAccessLevel( accessLevel );
					managedField = builder.build();
					JC.managedConfigurationItemService.updateManagedConfigurationItem(managedField);
				}
				else
					throw new GenericEntityException("Unable to lock custom field: " + cfName);
			}

			if (log.isDebugEnabled()) log.debug("Created new custom field for " + cfName);
		}
		else
			if (log.isDebugEnabled()) log.debug("Found pre-existing custom field for " + cfName);

		return customField;
	}

	/**
	 * Sets the available options for a custom field (assuming it is a select custom field) within
	 * all field configuration schemes that have that field with empty values (unset options).
	 * @param targetIssueTypeId the targeted issue type by id
	 * @param field the custom field to set the options for
	 * @param defaultPosition the zero-based position of the default option. A negative number means don't set a default (useful for checkbox options)
	 * @param values the option values in order as they will appear
	 */
	public void setOptionsForProjectNeutralFieldConfigurationSchemes(String[] targetIssueTypeIds, CustomField field, int defaultPosition, String ... values)
	{
		// allow passing of null values to mean nothing quietly.
		if (values == null) return;

		List<FieldConfigScheme> schemes = JC.fieldConfigSchemeManager.getConfigSchemesForField(field);
		
		
		// Recall: A field configuration scheme is a collection of field configurations mapped to issue types (each individual
		// issue type is associated with one field configuration). A field configuration is a listing of a subset of fields in
		// JIRA but configured in a particular way. By using a field configuration SCHEME, this allows us to "mix and match"
		// across field configurations ("Use FC1's settings for Bug, but FC2's settings for User Story, and FC3's settings
		// for Task"). Finally, the field configuration scheme can be used by different projects.
		// BUT NOW: in the programming world, a "FieldConfigScheme" appears to be a "flattened" concept, such that it is a
		// a set of field configurations mapped to a set of issue types, AND associated with a set of contexts. See
		// FieldConfigScheme documentation, and also the IssueTypeSchemeManager documentation.
		// https://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/fields/config/manager/IssueTypeSchemeManager.html
		log.debug("Field Name: " + field.getName());
		for (FieldConfigScheme scheme : schemes)
		{
			log.debug("Field Config Scheme: " + scheme.getName());
			if (scheme.isAllProjects()) // only look for schemes that are project-neutral (will essentially be the default scheme)
			{
				log.debug("Field Config Scheme is for all projects");
				log.debug("Target Issue Type ID's: " + Arrays.toString( targetIssueTypeIds ) );
				// map of issue type ID (NOT NAME as Atlassian's documentation says!) to field configuration
				Map<String, FieldConfig> fieldConfigMap = scheme.getConfigs();
				for (String issueTypeId : fieldConfigMap.keySet())
				{
					log.debug("Issue type having a field config: " + issueTypeId);

					for (String targetIssueTypeId : targetIssueTypeIds) // only adjust options for the issue types we are targetting
					{
						// the case where the field config is for all issue types (indicated with a null)
						if ((targetIssueTypeId == null && targetIssueTypeId == issueTypeId)
						// the case where a restricted set of issue types is intended
							|| targetIssueTypeId.equals(issueTypeId) )
						{
							FieldConfig fieldConfig = fieldConfigMap.get( issueTypeId );
							Options fieldOptions = JC.optionsManager.getOptions(fieldConfig);
							
							// only add options if it is empty (otherwise it is already installed and possibly customized)
							if (fieldOptions == null || fieldOptions.isEmpty())
							{
								long sequence = 1;
								for (String value : values)
								{
									// note that createOption assumes sequence is ONE-based.
									Option option = JC.optionsManager.createOption(fieldConfig, null, sequence++, value);
									if (defaultPosition >= 0 && defaultPosition == sequence - 2)
										field.getCustomFieldType().setDefaultValue(fieldConfig, option);
								}
							}
						}
					}
				}
			}
		}
	}
	
	private FieldScreen getOrCreateSingleTabFieldScreen(String scrName, String scrDescription, String scrTabName, 
		List<String> fieldIds)
	{
		FieldScreen fieldScreen = getFieldScreenByName(scrName);

		if (fieldScreen == null)
		{
			fieldScreen = new FieldScreenImpl(JC.fieldScreenManager);
			fieldScreen.setName(scrName);
			fieldScreen.setDescription(scrDescription);
			fieldScreen.store();
			
			FieldScreenTab tab = fieldScreen.addTab(scrTabName);
			for (String fieldId : fieldIds)
			{
				tab.addFieldScreenLayoutItem(fieldId);
			}
			
			// Though many sites list the following as a step, it generates a database error (unique index violated).
			// It is also MISSING from an Atlassian employee's github project
			// https://bitbucket.org/doklovic_atlassian/atlassian-beer-supply/src/aed567842e8299867e5581f11fd5ceae9a09a490/src/main/java/com/example/beersupply/components/BeerSupplyScreenCreator.java?at=master&fileviewer=file-view-default
			// JC.fieldScreenManager.createFieldScreen(forecastScreen);

			if (log.isDebugEnabled()) log.debug("Created new screen for " + scrName);
		}
		else
			if (log.isDebugEnabled()) log.debug("Found pre-existing screen for " + scrName);
		
		return fieldScreen;
	}
	
	private FieldScreenScheme getOrCreateFieldScreenScheme(String schName, String schDescription, 
		FieldScreen fieldScreen, ScreenableIssueOperation operation)
	{
		FieldScreenScheme fieldScreenScheme = getFieldScreenSchemeByName(schName);

		if (fieldScreenScheme == null)
		{
			fieldScreenScheme = new FieldScreenSchemeImpl(JC.fieldScreenSchemeManager);
			fieldScreenScheme.setName(schName);
			fieldScreenScheme.setDescription(schDescription);
			fieldScreenScheme.store();
			
			FieldScreenSchemeItemImpl fieldScreenSchemeItem = new FieldScreenSchemeItemImpl(JC.fieldScreenSchemeManager, JC.fieldScreenManager);
			fieldScreenSchemeItem.setFieldScreen(fieldScreen);
			fieldScreenSchemeItem.setFieldScreenScheme(fieldScreenScheme);
			fieldScreenSchemeItem.setIssueOperation(operation);
			fieldScreenSchemeItem.store();

			if (log.isDebugEnabled()) log.debug("Created new screen scheme for " + schName);
		}
		else
			if (log.isDebugEnabled()) log.debug("Found pre-existing screen scheme for " + schName);

		return fieldScreenScheme;
	}

	private IssueTypeScreenScheme getOrCreateIssueTypeScreenScheme(String issName, String issDescription, 
		FieldScreenScheme fieldScreenScheme, String[] issueTypeIds)
	{
		IssueTypeScreenScheme issueTypeScreenScheme = getIssueTypeScreenSchemeByName(issName);
		
		if (issueTypeScreenScheme == null)
		{
			issueTypeScreenScheme = new IssueTypeScreenSchemeImpl(JC.issueTypeScreenSchemeManager);
			issueTypeScreenScheme.setName(issName);
			issueTypeScreenScheme.setDescription(issDescription);
			issueTypeScreenScheme.store();
			
			IssueTypeScreenSchemeEntity issueTypeScreenSchemeEntity = null;
			
			// Map all passed in issue types
			for (String issueTypeId : issueTypeIds)
			{
				// Add the specific issue type to screen scheme mapping
				issueTypeScreenSchemeEntity = 
					new IssueTypeScreenSchemeEntityImpl(JC.issueTypeScreenSchemeManager, JC.fieldScreenSchemeManager, JC.constantsManager);
				issueTypeScreenSchemeEntity.setFieldScreenScheme(fieldScreenScheme);
				issueTypeScreenSchemeEntity.setIssueTypeId(issueTypeId);
				issueTypeScreenSchemeEntity.setIssueTypeScreenScheme(issueTypeScreenScheme);
				issueTypeScreenSchemeEntity.store();
			}

			// Add the default (all other issue types) to screen scheme mapping (using the default screen scheme)
			issueTypeScreenSchemeEntity = 
				new IssueTypeScreenSchemeEntityImpl(JC.issueTypeScreenSchemeManager, JC.fieldScreenSchemeManager, JC.constantsManager);
			issueTypeScreenSchemeEntity.setFieldScreenScheme(JC.fieldScreenSchemeManager.getFieldScreenScheme(FieldScreenSchemeManager.DEFAULT_FIELD_SCREEN_SCHEME_ID));
			issueTypeScreenSchemeEntity.setIssueTypeScreenScheme(issueTypeScreenScheme);
			issueTypeScreenSchemeEntity.store();

			if (log.isDebugEnabled()) log.debug("Created new issue type screen scheme for " + issName);
		}
		else
			if (log.isDebugEnabled()) log.debug("Found pre-existing issue type screen scheme for " + issName);

		return issueTypeScreenScheme;
	}

	private NavigableField getNavigableFieldByName(String name) throws FieldException
	{
		Set<NavigableField> allNavigableFields = JC.fieldManager.getNavigableFields();

		if (allNavigableFields != null && !allNavigableFields.isEmpty())
			for (NavigableField field : allNavigableFields)
				if (field.getName().equals(name)) return field;

		return null;
	}

	private IssueType getIssueTypeByName(String name)
	{
		Collection<IssueType> allIssueTypes = JC.issueTypeManager.getIssueTypes();
		
		if (allIssueTypes != null && !allIssueTypes.isEmpty())
			for (IssueType issueType : allIssueTypes)
				if (issueType.getName().equals(name)) return issueType;

		return null;
	}

	private FieldScreen getFieldScreenByName(String name)
	{
		Collection<FieldScreen> allFieldScreens = JC.fieldScreenManager.getFieldScreens();
		
		if (allFieldScreens != null && !allFieldScreens.isEmpty())
			for (FieldScreen fieldScreen : allFieldScreens)
				if (fieldScreen.getName().equals(name)) return fieldScreen;

		return null;
	}

	private FieldScreenScheme getFieldScreenSchemeByName(String name)
	{
		Collection<FieldScreenScheme> allFieldScreenSchemes = JC.fieldScreenSchemeManager.getFieldScreenSchemes();
		
		if (allFieldScreenSchemes != null && !allFieldScreenSchemes.isEmpty())
			for (FieldScreenScheme fieldScreenScheme : allFieldScreenSchemes)
				if (fieldScreenScheme.getName().equals(name)) return fieldScreenScheme;

		return null;
	}
	
	private IssueTypeScreenScheme getIssueTypeScreenSchemeByName(String name)
	{
		Collection<IssueTypeScreenScheme> allIssueTypeScreenSchemes = JC.issueTypeScreenSchemeManager.getIssueTypeScreenSchemes();

		if (allIssueTypeScreenSchemes != null)
			for (IssueTypeScreenScheme issueTypeScreenScheme : allIssueTypeScreenSchemes)
				if (issueTypeScreenScheme.getName().equals(name)) return issueTypeScreenScheme;

		return null;
	}

	private ProjectRole getOrCreateProjectRole(String roleName, String roleDescription)
	{
		ProjectRole projectRole = JC.projectRoleManager.getProjectRole(roleName);
		
		if (projectRole == null)
		{
			projectRole = JC.projectRoleManager.createRole(new ProjectRoleImpl(roleName, roleDescription));
			
			if (log.isDebugEnabled()) log.debug("Created new project role for " + roleName);
		}
		else
			if (log.isDebugEnabled()) log.debug("Found pre-existing project role for " + roleName);

		return projectRole;
	}

	public Properties getProperties() { return properties; }

	public IssueType getForecastIssueType() { return forecastIssueType; }
	public IssueType getForecastSubtaskIssueType() { return forecastSubtaskIssueType; }
	// The following needs to always return ALL FORECAST-SPECIFIC ISSUE TYPES
	public List<IssueType> getForecastIssueTypesList() { return Arrays.asList(forecastIssueType, forecastSubtaskIssueType); }

	public CustomField getForecastStatusCF() { return forecastStatusCF; }
	public CustomField getForecastCategoryCF() { return forecastCategoryCF; }

	public CustomField getForecastClosingDateCF() { return forecastClosingDateCF; }
	public CustomField getForecastBookingDateCF() { return forecastBookingDateCF; }
	public CustomField getForecastDeliveryDateCF() { return forecastDeliveryDateCF; }
	public CustomField getForecastRecognitionDateCF() { return forecastRecognitionDateCF; }

	public CustomField getForecastClosingDateReviewedCF() { return forecastClosingDateReviewedCF; }
	public CustomField getForecastBookingDateReviewedCF() { return forecastBookingDateReviewedCF; }
	public CustomField getForecastDeliveryDateReviewedCF() { return forecastDeliveryDateReviewedCF; }
	public CustomField getForecastRecognitionDateReviewedCF() { return forecastRecognitionDateReviewedCF; }

	public CustomField getForecastInitialPaymentAmountCF() { return forecastInitialPaymentAmountCF; }
	public CustomField getForecastMonthlyPaymentsAmountCF() { return forecastMonthlyPaymentsAmountCF; }
	public CustomField getForecastMonthlyPaymentsDurationCF() { return forecastMonthlyPaymentsDurationCF; }
	public CustomField getForecastTotalValueCF() { return forecastTotalValueCF; }
	
	public ProjectRole getForecastReviewersRole() { return forecastReviewersRole; }
}
